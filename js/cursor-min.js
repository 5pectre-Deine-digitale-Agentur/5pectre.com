let clientX=-100,clientY=-100;const innerCursor=document.querySelector(".cursor--small"),initCursor=()=>{document.addEventListener("mousemove",(t=>{clientX=t.clientX,clientY=t.clientY}));const t=()=>{innerCursor.style.transform=`translate(${clientX}px, ${clientY}px)`,requestAnimationFrame(t)};requestAnimationFrame(t)};initCursor();let group,stuckX,stuckY,fillOuterCursor,lastX=0,lastY=0,isStuck=!1,showCursor=!1;const initCanvas=()=>{const t=document.querySelector(".cursor--canvas"),e=75;paper.setup(t);let s=!1;const n=new paper.Path.RegularPolygon(new paper.Point(0,0),15,100);n.fillColor="rgba(0, 0, 0, 1)",n.smooth(),group=new paper.Group([n]),group.applyMatrix=!1;const o=n.segments.map((()=>new SimplexNoise));let i=[];const r=(t,e,s)=>(1-s)*t+s*e,c=(t,e,s,n,o)=>(t-e)*(o-n)/(s-e)+n;paper.view.onFrame=t=>{if(isStuck?isStuck&&(lastX=r(lastX,stuckX,.2),lastY=r(lastY,stuckY,.2),group.position=new paper.Point(lastX,lastY)):(lastX=r(lastX,clientX,.2),lastY=r(lastY,clientY,.2),group.position=new paper.Point(lastX,lastY)),isStuck&&n.bounds.width<e)n.scale(1.08);else if(!isStuck&&n.bounds.width>30){s&&(n.segments.forEach(((t,e)=>{t.point.set(i[e][0],i[e][1])})),s=!1,i=[]);const t=.92;n.scale(t)}isStuck&&n.bounds.width>=e&&(s=!0,0===i.length&&n.segments.forEach(((t,e)=>{i[e]=[t.point.x,t.point.y]})),n.segments.forEach(((e,s)=>{const n=o[s].noise2D(t.count/100,0),r=o[s].noise2D(t.count/100,1),a=c(n,-1,1,-4,4),l=c(r,-1,1,-4,4),u=i[s][0]+a,p=i[s][1]+l;e.point.set(u,p)}))),n.smooth()}};initCanvas();const initHovers=()=>{const t=t=>{const e=t.currentTarget.getBoundingClientRect();stuckX=Math.round(e.left+e.width/10),stuckY=Math.round(e.top+e.height/2),isStuck=!0},e=()=>{isStuck=!1};document.querySelectorAll(".link").forEach((s=>{s.addEventListener("mouseenter",t),s.addEventListener("mouseleave",e)}))};initHovers();